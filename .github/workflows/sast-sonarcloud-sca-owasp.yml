name: CI with SonarCloud + SCA

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ADWebApplication

    steps:
      # Step 1: Checkout source code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # REQUIRED for SonarCloud

      # Step 2: Set up .NET
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      # Step 3: Install SonarScanner for .NET
      - name: Install SonarScanner
        run: dotnet tool install --global dotnet-sonarscanner

      # Step 4: Begin SonarCloud analysis
      - name: SonarCloud Begin
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: >
          dotnet sonarscanner begin
          /k:"GDipSA-Team-5_AD-Project"
          /o:"gdipsa-team-5"
          /d:sonar.host.url="https://sonarcloud.io"
          /d:sonar.cs.opencover.reportsPaths="**/coverage.opencover.xml"
          /d:sonar.coverage.exclusions="**/Program.cs"

      # Step 5: Restore dependencies
      - name: Restore
        run: dotnet restore

      # Step 6: Build
      - name: Build
        run: dotnet build --no-restore

      # Step 7: Test with coverage
      - name: Test
        run: >
          dotnet test
          --no-build
          /p:CollectCoverage=true
          /p:CoverletOutputFormat=opencover
          /p:CoverletOutput=./coverage.opencover.xml

      # Step 8a: End SonarCloud analysis
      - name: SonarCloud End
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: dotnet sonarscanner end
      
      # Step 8b: Upload SonarCloud artifacts
      - name: Upload SonarCloud scan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sonarcloud-artifacts
          path: |
            ADWebApplication/.sonarqube/out
            ADWebApplication/coverage.opencover.xml

      # Step 9: Quality Gate enforcement
      - name: SonarCloud Quality Gate
        uses: SonarSource/sonarqube-quality-gate-action@v1
        with:
          scanMetadataReportFile: ADWebApplication/.sonarqube/out/.sonar/report-task.txt
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      # Step 10: Run OWASP Dependency-Check SCA
      - name: Run OWASP Dependency-Check SCA
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: ADWebApplication
          path: .
          format: ALL
          out: ./dependency-check-report
          args: >
            --exclude "./ADWebApplication.Tests/bin"
            --suppression dependency-check-suppressions.xml
        continue-on-error: true   # ensures report is generated even if vulnerabilities exist

      # Step 11: Upload Dependency-Check report
      - name: Upload Dependency-Check report
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-report
          path: ./dependency-check-report

      # Step 12: Fail workflow if CVSS >= 7
      - name: Fail workflow if high CVSS vulnerabilities found
        run: |
          REPORT_FILE=./dependency-check-report/dependency-check-report.xml

          # Exit if the report file doesn't exist
          if [ ! -f "$REPORT_FILE" ]; then
            echo "Dependency-Check report not found. Skipping CVSS check."
            exit 0
          fi

          # Count vulnerabilities with CVSSv3 base score >= 7
          HIGH_COUNT=$(xmllint --xpath "count(//vulnerability[number(cvssv3BaseScore) >= 7])" "$REPORT_FILE")
          
          if [ "$HIGH_COUNT" -gt 0 ]; then
            echo "High CVSS vulnerabilities found ($HIGH_COUNT)! Failing workflow."
            exit 1
          else
            echo "No high CVSS vulnerabilities found. Workflow passes."
          fi